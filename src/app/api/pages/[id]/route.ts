import { NextRequest, NextResponse } from "next/server"
import { cookies } from "next/headers"
import { prisma } from "@/lib/prisma"
import { getSessionUser } from "@/lib/auth"
import { updatePageSchema } from "@/lib/validators/pages"
import { z } from "zod"

// GET: Get page details
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const sessionToken = cookies().get("sessionToken")?.value
    if (!sessionToken) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

    const user = await getSessionUser(sessionToken)
    if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

    const page = await prisma.linkPage.findUnique({
      where: { id: params.id },
      include: { buttons: { orderBy: { order: 'asc' } } }
    })

    if (!page) return NextResponse.json({ error: "Page not found" }, { status: 404 })
    if (page.userId !== user.id) return NextResponse.json({ error: "Forbidden" }, { status: 403 })

    return NextResponse.json(page)
  } catch (error) {
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 })
  }
}

// PUT: Update page and buttons
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const sessionToken = cookies().get("sessionToken")?.value
    if (!sessionToken) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

    const user = await getSessionUser(sessionToken)
    if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

    const body = await req.json()

    // 1. Verify ownership
    const existingPage = await prisma.linkPage.findUnique({
      where: { id: params.id }
    })
    if (!existingPage) return NextResponse.json({ error: "Page not found" }, { status: 404 })
    if (existingPage.userId !== user.id) return NextResponse.json({ error: "Forbidden" }, { status: 403 })

    // 2. Validate Page Data
    const { buttons, ...pageData } = body
    const validatedPage = updatePageSchema.parse(pageData)

    // 3. Transaction update
    const updatedPage = await prisma.$transaction(async (tx) => {
      // Update Page Info
      const page = await tx.linkPage.update({
        where: { id: params.id },
        data: validatedPage
      })

      // Update Buttons (Full Replace Strategy for simplicity)
      // In a real app, we might want to diff, but for MVP this is robust
      if (buttons && Array.isArray(buttons)) {
        // Delete existing buttons not in the new list (or all and recreate? Recreating loses stats if not careful)
        // Better strategy: Upsert or smart update.
        // For now, let's just update existing ones and create new ones, and delete missing ones.

        const incomingIds = buttons.map((b: any) => b.id).filter((id: string) => !id.startsWith('temp_')) // Assuming temp IDs for new buttons? Or just use CUIDs?
        // Actually, the frontend generates random IDs. If they don't exist in DB, create them.

        // Simplest robust way for MVP: 
        // 1. Delete all buttons for this page
        // 2. Create all buttons from the list
        // DOWNSIDE: Loses click history (ButtonClick relation).
        // FIX: We must preserve IDs for existing buttons.

        // Let's do it properly:
        const currentButtons = await tx.linkButton.findMany({ where: { pageId: params.id } })
        const currentIds = new Set(currentButtons.map(b => b.id))
        const incomingButtonIds = new Set(buttons.map((b: any) => b.id))

        // Delete removed buttons
        const toDelete = currentButtons.filter(b => !incomingButtonIds.has(b.id)).map(b => b.id)
        if (toDelete.length > 0) {
          await tx.linkButton.deleteMany({ where: { id: { in: toDelete } } })
        }

        // Upsert (Update or Create)
        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i]
          // If ID exists in DB, update. If not (or it's a temp ID), create.
          // We can check if ID is a valid CUID or just try to update.
          // If the ID was generated by frontend (Math.random), it won't match any DB ID (CUID).
          // So we should probably ignore the frontend ID if it's not a CUID and create a new one.
          // But we need to track it.

          // Strategy: If it's in currentIds, update. Else create.
          if (currentIds.has(btn.id)) {
            await tx.linkButton.update({
              where: { id: btn.id },
              data: {
                label: btn.label,
                value: btn.value,
                type: btn.type,
                order: i,
                isActive: btn.isActive
              }
            })
          } else {
            await tx.linkButton.create({
              data: {
                pageId: params.id,
                label: btn.label,
                value: btn.value,
                type: btn.type,
                order: i,
                isActive: btn.isActive
                // id will be auto-generated CUID
              }
            })
          }
        }
      }

      return page
    })

    return NextResponse.json(updatedPage)

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors }, { status: 400 })
    }
    console.error("Error updating page:", error)
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 })
  }
}

// DELETE: Delete page
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const sessionToken = cookies().get("sessionToken")?.value
    if (!sessionToken) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

    const user = await getSessionUser(sessionToken)
    if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

    const existingPage = await prisma.linkPage.findUnique({
      where: { id: params.id }
    })
    if (!existingPage) return NextResponse.json({ error: "Page not found" }, { status: 404 })
    if (existingPage.userId !== user.id) return NextResponse.json({ error: "Forbidden" }, { status: 403 })

    await prisma.linkPage.delete({
      where: { id: params.id }
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 })
  }
}
